{"ast":null,"code":"import { isTopOfSubtree, hasSameParent, getPathOnLevel, moveAfterPath } from './path';\nimport { between } from './handy';\nexport var getFlatItemPath = function getFlatItemPath(flattenedTree, sourceIndex) {\n  return flattenedTree[sourceIndex].path;\n};\n\n/*\n  Calculates the source path after drag&drop ends\n */\nexport var getSourcePath = getFlatItemPath;\n\n/*\n    Calculates the destination path after drag&drop ends\n\n    During dragging the items are displaced based on the location of the dragged item.\n    Displacement depends on which direction the item is coming from.\n\n    index\n          -----------        -----------\n    0     | item 0           | item 1 (displaced)\n          -----------        -----------\n    1     | item 1           | item 2 (displaced)\n          -----------  --->  -----------      -----------\n    2     | item 2                            | item 0 (dragged)\n          -----------        -----------      -----------\n    3     | item 3           | item 3\n          -----------        -----------\n\n   */\nexport var getDestinationPath = function getDestinationPath(flattenedTree, sourceIndex, destinationIndex, level) {\n  // Moving down\n  var down = destinationIndex > sourceIndex;\n  // Path of the source location\n  var sourcePath = getSourcePath(flattenedTree, sourceIndex);\n  // Stayed at the same place\n  var sameIndex = destinationIndex === sourceIndex;\n  // Path of the upper item where the item was dropped\n  var upperPath = down ? flattenedTree[destinationIndex].path : flattenedTree[destinationIndex - 1] && flattenedTree[destinationIndex - 1].path;\n  // Path of the lower item where the item was dropped\n  var lowerPath = down || sameIndex ? flattenedTree[destinationIndex + 1] && flattenedTree[destinationIndex + 1].path : flattenedTree[destinationIndex].path;\n\n  /*\n    We are going to differentiate 4 cases:\n      - item didn't change position, only moved horizontally\n      - item moved to the top of a list\n      - item moved between two items on the same level\n      - item moved to the end of list. This is an ambiguous case.\n  */\n\n  // Stayed in place, might moved horizontally\n  if (sameIndex) {\n    if (typeof level !== 'number') {\n      return sourcePath;\n    }\n    if (!upperPath) {\n      // Not possible to move\n      return sourcePath;\n    }\n    var minLevel = lowerPath ? lowerPath.length : 1;\n    var maxLevel = Math.max(sourcePath.length, upperPath.length);\n    var finalLevel = between(minLevel, maxLevel, level);\n    var sameLevel = finalLevel === sourcePath.length;\n    if (sameLevel) {\n      // Didn't change level\n      return sourcePath;\n    }\n    var previousPathOnTheFinalLevel = getPathOnLevel(upperPath, finalLevel);\n    return moveAfterPath(previousPathOnTheFinalLevel, sourcePath);\n  }\n\n  // Moved to top of the list\n  if (lowerPath && isTopOfSubtree(lowerPath, upperPath)) {\n    return lowerPath;\n  }\n\n  // Moved between two items on the same level\n  if (upperPath && lowerPath && hasSameParent(upperPath, lowerPath)) {\n    if (down && hasSameParent(upperPath, sourcePath)) {\n      // if item was moved down within the list, it will replace the displaced item\n      return upperPath;\n    }\n    return lowerPath;\n  }\n\n  // Moved to end of list\n  if (upperPath) {\n    // this means that the upper item is deeper in the tree.\n    var _finalLevel = calculateFinalLevel(sourcePath, upperPath, lowerPath, level);\n    // Insert to higher levels\n    var _previousPathOnTheFinalLevel = getPathOnLevel(upperPath, _finalLevel);\n    return moveAfterPath(_previousPathOnTheFinalLevel, sourcePath);\n  }\n\n  // In case of any other impossible case\n  return sourcePath;\n};\nvar calculateFinalLevel = function calculateFinalLevel(sourcePath, upperPath, lowerPath, level) {\n  var upperLevel = upperPath.length;\n  var lowerLevel = lowerPath ? lowerPath.length : 1;\n  var sourceLevel = sourcePath.length;\n  if (typeof level === 'number') {\n    // Explicit disambiguation based on level\n    // Final level has to be between the levels of bounding items, inclusive\n    return between(lowerLevel, upperLevel, level);\n  }\n  // Automatic disambiguation based on the initial level\n  return sourceLevel <= lowerLevel ? lowerLevel : upperLevel;\n};\nexport var getItemById = function getItemById(flattenedTree, id) {\n  return flattenedTree.find(function (item) {\n    return item.item.id === id;\n  });\n};\nexport var getIndexById = function getIndexById(flattenedTree, id) {\n  return flattenedTree.findIndex(function (item) {\n    return item.item.id === id;\n  });\n};","map":{"version":3,"names":["isTopOfSubtree","hasSameParent","getPathOnLevel","moveAfterPath","between","getFlatItemPath","flattenedTree","sourceIndex","path","getSourcePath","getDestinationPath","destinationIndex","level","down","sourcePath","sameIndex","upperPath","lowerPath","minLevel","length","maxLevel","Math","max","finalLevel","sameLevel","previousPathOnTheFinalLevel","_finalLevel","calculateFinalLevel","_previousPathOnTheFinalLevel","upperLevel","lowerLevel","sourceLevel","getItemById","id","find","item","getIndexById","findIndex"],"sources":["/Users/tyna/code/select_critique_package/my_component/frontend/node_modules/@atlaskit/tree/dist/esm/utils/flat-tree.js"],"sourcesContent":["import { isTopOfSubtree, hasSameParent, getPathOnLevel, moveAfterPath } from './path';\nimport { between } from './handy';\nexport var getFlatItemPath = function getFlatItemPath(flattenedTree, sourceIndex) {\n  return flattenedTree[sourceIndex].path;\n};\n\n/*\n  Calculates the source path after drag&drop ends\n */\nexport var getSourcePath = getFlatItemPath;\n\n/*\n    Calculates the destination path after drag&drop ends\n\n    During dragging the items are displaced based on the location of the dragged item.\n    Displacement depends on which direction the item is coming from.\n\n    index\n          -----------        -----------\n    0     | item 0           | item 1 (displaced)\n          -----------        -----------\n    1     | item 1           | item 2 (displaced)\n          -----------  --->  -----------      -----------\n    2     | item 2                            | item 0 (dragged)\n          -----------        -----------      -----------\n    3     | item 3           | item 3\n          -----------        -----------\n\n   */\nexport var getDestinationPath = function getDestinationPath(flattenedTree, sourceIndex, destinationIndex, level) {\n  // Moving down\n  var down = destinationIndex > sourceIndex;\n  // Path of the source location\n  var sourcePath = getSourcePath(flattenedTree, sourceIndex);\n  // Stayed at the same place\n  var sameIndex = destinationIndex === sourceIndex;\n  // Path of the upper item where the item was dropped\n  var upperPath = down ? flattenedTree[destinationIndex].path : flattenedTree[destinationIndex - 1] && flattenedTree[destinationIndex - 1].path;\n  // Path of the lower item where the item was dropped\n  var lowerPath = down || sameIndex ? flattenedTree[destinationIndex + 1] && flattenedTree[destinationIndex + 1].path : flattenedTree[destinationIndex].path;\n\n  /*\n    We are going to differentiate 4 cases:\n      - item didn't change position, only moved horizontally\n      - item moved to the top of a list\n      - item moved between two items on the same level\n      - item moved to the end of list. This is an ambiguous case.\n  */\n\n  // Stayed in place, might moved horizontally\n  if (sameIndex) {\n    if (typeof level !== 'number') {\n      return sourcePath;\n    }\n    if (!upperPath) {\n      // Not possible to move\n      return sourcePath;\n    }\n    var minLevel = lowerPath ? lowerPath.length : 1;\n    var maxLevel = Math.max(sourcePath.length, upperPath.length);\n    var finalLevel = between(minLevel, maxLevel, level);\n    var sameLevel = finalLevel === sourcePath.length;\n    if (sameLevel) {\n      // Didn't change level\n      return sourcePath;\n    }\n    var previousPathOnTheFinalLevel = getPathOnLevel(upperPath, finalLevel);\n    return moveAfterPath(previousPathOnTheFinalLevel, sourcePath);\n  }\n\n  // Moved to top of the list\n  if (lowerPath && isTopOfSubtree(lowerPath, upperPath)) {\n    return lowerPath;\n  }\n\n  // Moved between two items on the same level\n  if (upperPath && lowerPath && hasSameParent(upperPath, lowerPath)) {\n    if (down && hasSameParent(upperPath, sourcePath)) {\n      // if item was moved down within the list, it will replace the displaced item\n      return upperPath;\n    }\n    return lowerPath;\n  }\n\n  // Moved to end of list\n  if (upperPath) {\n    // this means that the upper item is deeper in the tree.\n    var _finalLevel = calculateFinalLevel(sourcePath, upperPath, lowerPath, level);\n    // Insert to higher levels\n    var _previousPathOnTheFinalLevel = getPathOnLevel(upperPath, _finalLevel);\n    return moveAfterPath(_previousPathOnTheFinalLevel, sourcePath);\n  }\n\n  // In case of any other impossible case\n  return sourcePath;\n};\nvar calculateFinalLevel = function calculateFinalLevel(sourcePath, upperPath, lowerPath, level) {\n  var upperLevel = upperPath.length;\n  var lowerLevel = lowerPath ? lowerPath.length : 1;\n  var sourceLevel = sourcePath.length;\n  if (typeof level === 'number') {\n    // Explicit disambiguation based on level\n    // Final level has to be between the levels of bounding items, inclusive\n    return between(lowerLevel, upperLevel, level);\n  }\n  // Automatic disambiguation based on the initial level\n  return sourceLevel <= lowerLevel ? lowerLevel : upperLevel;\n};\nexport var getItemById = function getItemById(flattenedTree, id) {\n  return flattenedTree.find(function (item) {\n    return item.item.id === id;\n  });\n};\nexport var getIndexById = function getIndexById(flattenedTree, id) {\n  return flattenedTree.findIndex(function (item) {\n    return item.item.id === id;\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}