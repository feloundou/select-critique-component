{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n/*\n  Checking if two given path are equal\n */\nexport var isSamePath = function isSamePath(a, b) {\n  if (a === b) {\n    return true;\n  }\n  return a.length === b.length && a.every(function (v, i) {\n    return v === b[i];\n  });\n};\n\n/*\n  Checks if the two paths have the same parent\n */\nexport var hasSameParent = function hasSameParent(a, b) {\n  return isSamePath(getParentPath(a), getParentPath(b));\n};\n\n/*\n  Calculates the parent path for a path\n*/\nexport var getParentPath = function getParentPath(child) {\n  return child.slice(0, child.length - 1);\n};\n\n/*\n  It checks if the item is on top of a sub tree based on the two neighboring items, which are above or below the item.\n*/\nexport var isTopOfSubtree = function isTopOfSubtree(belowPath, abovePath) {\n  return !abovePath || isParentOf(abovePath, belowPath);\n};\nvar isParentOf = function isParentOf(parent, child) {\n  return isSamePath(parent, getParentPath(child));\n};\nexport var getIndexAmongSiblings = function getIndexAmongSiblings(path) {\n  var lastIndex = path[path.length - 1];\n  return lastIndex;\n};\nexport var getPathOnLevel = function getPathOnLevel(path, level) {\n  return path.slice(0, level);\n};\nexport var moveAfterPath = function moveAfterPath(after, from) {\n  var newPath = _toConsumableArray(after);\n  var movedDownOnTheSameLevel = isLowerSibling(newPath, from);\n  if (!movedDownOnTheSameLevel) {\n    // not moved within the same subtree\n    newPath[newPath.length - 1] += 1;\n  }\n  return newPath;\n};\nexport var isLowerSibling = function isLowerSibling(a, other) {\n  return hasSameParent(a, other) && getIndexAmongSiblings(a) > getIndexAmongSiblings(other);\n};","map":{"version":3,"names":["_toConsumableArray","isSamePath","a","b","length","every","v","i","hasSameParent","getParentPath","child","slice","isTopOfSubtree","belowPath","abovePath","isParentOf","parent","getIndexAmongSiblings","path","lastIndex","getPathOnLevel","level","moveAfterPath","after","from","newPath","movedDownOnTheSameLevel","isLowerSibling","other"],"sources":["/Users/tyna/code/select_critique_package/my_component/frontend/node_modules/@atlaskit/tree/dist/esm/utils/path.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n/*\n  Checking if two given path are equal\n */\nexport var isSamePath = function isSamePath(a, b) {\n  if (a === b) {\n    return true;\n  }\n  return a.length === b.length && a.every(function (v, i) {\n    return v === b[i];\n  });\n};\n\n/*\n  Checks if the two paths have the same parent\n */\nexport var hasSameParent = function hasSameParent(a, b) {\n  return isSamePath(getParentPath(a), getParentPath(b));\n};\n\n/*\n  Calculates the parent path for a path\n*/\nexport var getParentPath = function getParentPath(child) {\n  return child.slice(0, child.length - 1);\n};\n\n/*\n  It checks if the item is on top of a sub tree based on the two neighboring items, which are above or below the item.\n*/\nexport var isTopOfSubtree = function isTopOfSubtree(belowPath, abovePath) {\n  return !abovePath || isParentOf(abovePath, belowPath);\n};\nvar isParentOf = function isParentOf(parent, child) {\n  return isSamePath(parent, getParentPath(child));\n};\nexport var getIndexAmongSiblings = function getIndexAmongSiblings(path) {\n  var lastIndex = path[path.length - 1];\n  return lastIndex;\n};\nexport var getPathOnLevel = function getPathOnLevel(path, level) {\n  return path.slice(0, level);\n};\nexport var moveAfterPath = function moveAfterPath(after, from) {\n  var newPath = _toConsumableArray(after);\n  var movedDownOnTheSameLevel = isLowerSibling(newPath, from);\n  if (!movedDownOnTheSameLevel) {\n    // not moved within the same subtree\n    newPath[newPath.length - 1] += 1;\n  }\n  return newPath;\n};\nexport var isLowerSibling = function isLowerSibling(a, other) {\n  return hasSameParent(a, other) && getIndexAmongSiblings(a) > getIndexAmongSiblings(other);\n};"],"mappings":"AAAA,OAAOA,kBAAkB,MAAM,0CAA0C;AACzE;AACA;AACA;AACA,OAAO,IAAIC,UAAU,GAAG,SAASA,UAAUA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAChD,IAAID,CAAC,KAAKC,CAAC,EAAE;IACX,OAAO,IAAI;EACb;EACA,OAAOD,CAAC,CAACE,MAAM,KAAKD,CAAC,CAACC,MAAM,IAAIF,CAAC,CAACG,KAAK,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;IACtD,OAAOD,CAAC,KAAKH,CAAC,CAACI,CAAC,CAAC;EACnB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA,OAAO,IAAIC,aAAa,GAAG,SAASA,aAAaA,CAACN,CAAC,EAAEC,CAAC,EAAE;EACtD,OAAOF,UAAU,CAACQ,aAAa,CAACP,CAAC,CAAC,EAAEO,aAAa,CAACN,CAAC,CAAC,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA,OAAO,IAAIM,aAAa,GAAG,SAASA,aAAaA,CAACC,KAAK,EAAE;EACvD,OAAOA,KAAK,CAACC,KAAK,CAAC,CAAC,EAAED,KAAK,CAACN,MAAM,GAAG,CAAC,CAAC;AACzC,CAAC;;AAED;AACA;AACA;AACA,OAAO,IAAIQ,cAAc,GAAG,SAASA,cAAcA,CAACC,SAAS,EAAEC,SAAS,EAAE;EACxE,OAAO,CAACA,SAAS,IAAIC,UAAU,CAACD,SAAS,EAAED,SAAS,CAAC;AACvD,CAAC;AACD,IAAIE,UAAU,GAAG,SAASA,UAAUA,CAACC,MAAM,EAAEN,KAAK,EAAE;EAClD,OAAOT,UAAU,CAACe,MAAM,EAAEP,aAAa,CAACC,KAAK,CAAC,CAAC;AACjD,CAAC;AACD,OAAO,IAAIO,qBAAqB,GAAG,SAASA,qBAAqBA,CAACC,IAAI,EAAE;EACtE,IAAIC,SAAS,GAAGD,IAAI,CAACA,IAAI,CAACd,MAAM,GAAG,CAAC,CAAC;EACrC,OAAOe,SAAS;AAClB,CAAC;AACD,OAAO,IAAIC,cAAc,GAAG,SAASA,cAAcA,CAACF,IAAI,EAAEG,KAAK,EAAE;EAC/D,OAAOH,IAAI,CAACP,KAAK,CAAC,CAAC,EAAEU,KAAK,CAAC;AAC7B,CAAC;AACD,OAAO,IAAIC,aAAa,GAAG,SAASA,aAAaA,CAACC,KAAK,EAAEC,IAAI,EAAE;EAC7D,IAAIC,OAAO,GAAGzB,kBAAkB,CAACuB,KAAK,CAAC;EACvC,IAAIG,uBAAuB,GAAGC,cAAc,CAACF,OAAO,EAAED,IAAI,CAAC;EAC3D,IAAI,CAACE,uBAAuB,EAAE;IAC5B;IACAD,OAAO,CAACA,OAAO,CAACrB,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC;EAClC;EACA,OAAOqB,OAAO;AAChB,CAAC;AACD,OAAO,IAAIE,cAAc,GAAG,SAASA,cAAcA,CAACzB,CAAC,EAAE0B,KAAK,EAAE;EAC5D,OAAOpB,aAAa,CAACN,CAAC,EAAE0B,KAAK,CAAC,IAAIX,qBAAqB,CAACf,CAAC,CAAC,GAAGe,qBAAqB,CAACW,KAAK,CAAC;AAC3F,CAAC"},"metadata":{},"sourceType":"module"}